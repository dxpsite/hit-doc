#### Данная функция
- принимает в качестве аргументов
```
строка
```
возвращает
```
строка
```
#### В данной функции вы должны
- заэнкодить все символы которые не являются unreserved
     - включение и выключение слеша из этого списка обусловлено необходимостью энкодить и урлы и обычные параметры
```
A-Za-z0-9._~-
```
```
A-Za-z0-9._~/-
```
 
- заменить все плюсы на %20
- после энкодинга необходимо прогнать полученную строку через функцию (_canonicalize) которая выполнит следующее:
  - идет по строке
    - если встречается %.. то разъенкоживает символ а затем если он не unreserved то энкодят его снова
    - если встречается простой символ то оставляем его как есть а затем если он не unreserved то энкодим его
    - (данная функция обеспечивает абсолютно правильный энкодинг вне зависимости от пришедших параметров)

#### Прилагается пример данной функции на языке perl
```
sub _canonicalize {
    my ($uri, $EncodeSlash) = @_;
    defined $EncodeSlash ? $UNRESERVED{"/"} = 0 :  $UNRESERVED{"/"} = 1;
    $uri =~ s/\+/%20/g;
    $uri =~ s{\G%(..)|(.)}{
        my $c = $1 ? chr(hex($1)) : $2;
        $UNRESERVED{$c} ? $c : sprintf "%%%02X", ord($c)
    }ge;
    $uri =~ s/\+/%20/g;
    return $uri;
}
sub _uri_encode {
    my ($uri, $EncodeSlash) = @_;
    my $unreserved_string = defined $EncodeSlash ? "A-Za-z0-9._~-" : "A-Za-z0-9._~/-";
    $uri =~ s{([^$unreserved_string])}{ sprintf '%%%02X',ord($1) }sge;
    $uri =~ s/\+/%20/g;
    $uri = _canonicalize($uri, $EncodeSlash);
    return $uri;

}
```